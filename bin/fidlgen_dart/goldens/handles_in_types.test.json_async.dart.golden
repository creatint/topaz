// WARNING: This file is machine generated by fidlgen.

library fidl_test_name_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zx;

// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters

enum UnionWithHandleTag {
  $unknown,
  h, // 0x1
}

const Map<int, UnionWithHandleTag> _UnionWithHandleTag_map = {
  1: UnionWithHandleTag.h,
};

class UnionWithHandle extends $fidl.XUnion {
  const UnionWithHandle.withH($zx.Vmo value)
      : _ordinal = 1,
        _data = value;

  UnionWithHandle._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  UnionWithHandleTag get $tag {
    final UnionWithHandleTag $rawtag = _UnionWithHandleTag_map[_ordinal];
    return $rawtag == null ? UnionWithHandleTag.$unknown : $rawtag;
  }

  $zx.Vmo get h {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'UnionWithHandle.h($h)';
      default:
        return 'UnionWithHandle.<UNKNOWN>';
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static UnionWithHandle _ctor(int ordinal, Object data) {
    return UnionWithHandle._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<UnionWithHandle> kUnionWithHandle_Type =
    $fidl.XUnionType<UnionWithHandle>(
  members: <int, $fidl.FidlType>{
    1: $fidl.VmoType(nullable: false),
  },
  ctor: UnionWithHandle._ctor,
  nullable: false,
  flexible: true,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<UnionWithHandle> kUnionWithHandle_OptType =
    $fidl.XUnionType<UnionWithHandle>(
  members: <int, $fidl.FidlType>{
    1: $fidl.VmoType(nullable: false),
  },
  ctor: UnionWithHandle._ctor,
  nullable: true,
  flexible: true,
);

class HandlesInTypes extends $fidl.Struct {
  const HandlesInTypes({
    @required this.normalHandle,
    @required this.handleInVec,
    @required this.handleInArray,
    @required this.handleInMixedVecArray,
    @required this.tableWithHandle,
    @required this.unionWithHandle,
  });
  HandlesInTypes.clone(
    HandlesInTypes $orig, {
    $zx.Vmo normalHandle,
    List<$zx.Vmo> handleInVec,
    List<$zx.Vmo> handleInArray,
    List<List<$zx.Vmo>> handleInMixedVecArray,
    TableWithHandle tableWithHandle,
    UnionWithHandle unionWithHandle,
  }) : this(
          normalHandle: normalHandle ?? $orig.normalHandle,
          handleInVec: handleInVec ?? $orig.handleInVec,
          handleInArray: handleInArray ?? $orig.handleInArray,
          handleInMixedVecArray:
              handleInMixedVecArray ?? $orig.handleInMixedVecArray,
          tableWithHandle: tableWithHandle ?? $orig.tableWithHandle,
          unionWithHandle: unionWithHandle ?? $orig.unionWithHandle,
        );

  HandlesInTypes._(List<Object> argv)
      : normalHandle = argv[0],
        handleInVec = argv[1],
        handleInArray = argv[2],
        handleInMixedVecArray = argv[3],
        tableWithHandle = argv[4],
        unionWithHandle = argv[5];
  final $zx.Vmo normalHandle;
  final List<$zx.Vmo> handleInVec;
  final List<$zx.Vmo> handleInArray;
  final List<List<$zx.Vmo>> handleInMixedVecArray;
  final TableWithHandle tableWithHandle;
  final UnionWithHandle unionWithHandle;

  @override
  List<Object> get $fields {
    return <Object>[
      normalHandle,
      handleInVec,
      handleInArray,
      handleInMixedVecArray,
      tableWithHandle,
      unionWithHandle,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'HandlesInTypes' r'(normalHandle: ' +
        normalHandle.toString() +
        r', handleInVec: ' +
        handleInVec.toString() +
        r', handleInArray: ' +
        handleInArray.toString() +
        r', handleInMixedVecArray: ' +
        handleInMixedVecArray.toString() +
        r', tableWithHandle: ' +
        tableWithHandle.toString() +
        r', unionWithHandle: ' +
        unionWithHandle.toString() +
        r')';
  }

  static HandlesInTypes _ctor(List<Object> argv) => HandlesInTypes._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<HandlesInTypes> kHandlesInTypes_Type =
    $fidl.StructType<HandlesInTypes>(
  inlineSize: 104,
  members: <$fidl.MemberType>[
    $fidl.MemberType<$zx.Vmo>(type: $fidl.VmoType(nullable: false), offset: 0),
    $fidl.MemberType<List<$zx.Vmo>>(
        type: $fidl.VectorType<List<$zx.Vmo>>(
            element: $fidl.VmoType(nullable: false),
            maybeElementCount: null,
            nullable: false),
        offset: 8),
    $fidl.MemberType<List<$zx.Vmo>>(
        type: $fidl.ArrayType<List<$zx.Vmo>>(
            element: $fidl.VmoType(nullable: false), elementCount: 5),
        offset: 24),
    $fidl.MemberType<List<List<$zx.Vmo>>>(
        type: $fidl.VectorType<List<List<$zx.Vmo>>>(
            element: $fidl.ArrayType<List<$zx.Vmo>>(
                element: $fidl.VmoType(nullable: false), elementCount: 5),
            maybeElementCount: null,
            nullable: false),
        offset: 48),
    $fidl.MemberType<TableWithHandle>(type: kTableWithHandle_Type, offset: 64),
    $fidl.MemberType<UnionWithHandle>(type: kUnionWithHandle_Type, offset: 80),
  ],
  ctor: HandlesInTypes._ctor,
);

class TableWithHandle extends $fidl.Table {
  const TableWithHandle({
    this.h,
  });

  TableWithHandle._(Map<int, dynamic> argv) : h = argv[1];
  final $zx.Vmo h;

  @override
  Map<int, dynamic> get $fields {
    return {
      1: h,
    };
  }

  static TableWithHandle _ctor(Map<int, dynamic> argv) =>
      TableWithHandle._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.TableType<TableWithHandle> kTableWithHandle_Type =
    $fidl.TableType<TableWithHandle>(
  inlineSize: 16,
  members: <int, $fidl.FidlType>{
    1: $fidl.VmoType(nullable: false),
  },
  ctor: TableWithHandle._ctor,
);

// ignore: unused_element, avoid_private_typedef_functions
typedef _VoidCallback = void Function();
