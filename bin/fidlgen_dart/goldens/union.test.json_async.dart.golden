// WARNING: This file is machine generated by fidlgen.

library fidl_fidl_test_json_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zx;

// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters

enum PizzaOrPastaTag {
  pizza, // 0x1
  pasta, // 0x2
}

const Map<int, PizzaOrPastaTag> _PizzaOrPastaTag_map = {
  1: PizzaOrPastaTag.pizza,
  2: PizzaOrPastaTag.pasta,
};

class PizzaOrPasta extends $fidl.XUnion {
  const PizzaOrPasta.withPizza(Pizza value)
      : _ordinal = 1,
        _data = value;

  const PizzaOrPasta.withPasta(Pasta value)
      : _ordinal = 2,
        _data = value;

  PizzaOrPasta._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  PizzaOrPastaTag get $tag => _PizzaOrPastaTag_map[_ordinal];

  Pizza get pizza {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  Pasta get pasta {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'PizzaOrPasta.pizza($pizza)';
      case 2:
        return 'PizzaOrPasta.pasta($pasta)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static PizzaOrPasta _ctor(int ordinal, Object data) {
    return PizzaOrPasta._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<PizzaOrPasta> kPizzaOrPasta_Type =
    $fidl.XUnionType<PizzaOrPasta>(
  members: <int, $fidl.FidlType>{
    1: kPizza_Type,
    2: kPasta_Type,
  },
  ctor: PizzaOrPasta._ctor,
  nullable: false,
  flexible: false,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<PizzaOrPasta> kPizzaOrPasta_OptType =
    $fidl.XUnionType<PizzaOrPasta>(
  members: <int, $fidl.FidlType>{
    1: kPizza_Type,
    2: kPasta_Type,
  },
  ctor: PizzaOrPasta._ctor,
  nullable: true,
  flexible: false,
);

enum ExplicitPizzaOrPastaTag {
  pizza, // 0x1
  pasta, // 0x4
}

const Map<int, ExplicitPizzaOrPastaTag> _ExplicitPizzaOrPastaTag_map = {
  1: ExplicitPizzaOrPastaTag.pizza,
  4: ExplicitPizzaOrPastaTag.pasta,
};

class ExplicitPizzaOrPasta extends $fidl.XUnion {
  const ExplicitPizzaOrPasta.withPizza(Pizza value)
      : _ordinal = 1,
        _data = value;

  const ExplicitPizzaOrPasta.withPasta(Pasta value)
      : _ordinal = 4,
        _data = value;

  ExplicitPizzaOrPasta._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ExplicitPizzaOrPastaTag get $tag => _ExplicitPizzaOrPastaTag_map[_ordinal];

  Pizza get pizza {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  Pasta get pasta {
    if (_ordinal != 4) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'ExplicitPizzaOrPasta.pizza($pizza)';
      case 4:
        return 'ExplicitPizzaOrPasta.pasta($pasta)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ExplicitPizzaOrPasta _ctor(int ordinal, Object data) {
    return ExplicitPizzaOrPasta._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<ExplicitPizzaOrPasta> kExplicitPizzaOrPasta_Type =
    $fidl.XUnionType<ExplicitPizzaOrPasta>(
  members: <int, $fidl.FidlType>{
    1: kPizza_Type,
    4: kPasta_Type,
  },
  ctor: ExplicitPizzaOrPasta._ctor,
  nullable: false,
  flexible: false,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<ExplicitPizzaOrPasta> kExplicitPizzaOrPasta_OptType =
    $fidl.XUnionType<ExplicitPizzaOrPasta>(
  members: <int, $fidl.FidlType>{
    1: kPizza_Type,
    4: kPasta_Type,
  },
  ctor: ExplicitPizzaOrPasta._ctor,
  nullable: true,
  flexible: false,
);

enum FlexiblePizzaOrPastaTag {
  pizza, // 0x1
  pasta, // 0x2
}

const Map<int, FlexiblePizzaOrPastaTag> _FlexiblePizzaOrPastaTag_map = {
  1: FlexiblePizzaOrPastaTag.pizza,
  2: FlexiblePizzaOrPastaTag.pasta,
};

class FlexiblePizzaOrPasta extends $fidl.XUnion {
  const FlexiblePizzaOrPasta.withPizza(Pizza value)
      : _ordinal = 1,
        _data = value;

  const FlexiblePizzaOrPasta.withPasta(Pasta value)
      : _ordinal = 2,
        _data = value;

  FlexiblePizzaOrPasta._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  FlexiblePizzaOrPastaTag get $tag => _FlexiblePizzaOrPastaTag_map[_ordinal];

  Pizza get pizza {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  Pasta get pasta {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'FlexiblePizzaOrPasta.pizza($pizza)';
      case 2:
        return 'FlexiblePizzaOrPasta.pasta($pasta)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static FlexiblePizzaOrPasta _ctor(int ordinal, Object data) {
    return FlexiblePizzaOrPasta._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<FlexiblePizzaOrPasta> kFlexiblePizzaOrPasta_Type =
    $fidl.XUnionType<FlexiblePizzaOrPasta>(
  members: <int, $fidl.FidlType>{
    1: kPizza_Type,
    2: kPasta_Type,
  },
  ctor: FlexiblePizzaOrPasta._ctor,
  nullable: false,
  flexible: false,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<FlexiblePizzaOrPasta> kFlexiblePizzaOrPasta_OptType =
    $fidl.XUnionType<FlexiblePizzaOrPasta>(
  members: <int, $fidl.FidlType>{
    1: kPizza_Type,
    2: kPasta_Type,
  },
  ctor: FlexiblePizzaOrPasta._ctor,
  nullable: true,
  flexible: false,
);

enum StrictPizzaOrPastaTag {
  pizza, // 0x1
  pasta, // 0x2
}

const Map<int, StrictPizzaOrPastaTag> _StrictPizzaOrPastaTag_map = {
  1: StrictPizzaOrPastaTag.pizza,
  2: StrictPizzaOrPastaTag.pasta,
};

class StrictPizzaOrPasta extends $fidl.XUnion {
  const StrictPizzaOrPasta.withPizza(Pizza value)
      : _ordinal = 1,
        _data = value;

  const StrictPizzaOrPasta.withPasta(Pasta value)
      : _ordinal = 2,
        _data = value;

  StrictPizzaOrPasta._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  StrictPizzaOrPastaTag get $tag => _StrictPizzaOrPastaTag_map[_ordinal];

  Pizza get pizza {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  Pasta get pasta {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'StrictPizzaOrPasta.pizza($pizza)';
      case 2:
        return 'StrictPizzaOrPasta.pasta($pasta)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static StrictPizzaOrPasta _ctor(int ordinal, Object data) {
    return StrictPizzaOrPasta._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<StrictPizzaOrPasta> kStrictPizzaOrPasta_Type =
    $fidl.XUnionType<StrictPizzaOrPasta>(
  members: <int, $fidl.FidlType>{
    1: kPizza_Type,
    2: kPasta_Type,
  },
  ctor: StrictPizzaOrPasta._ctor,
  nullable: false,
  flexible: false,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<StrictPizzaOrPasta> kStrictPizzaOrPasta_OptType =
    $fidl.XUnionType<StrictPizzaOrPasta>(
  members: <int, $fidl.FidlType>{
    1: kPizza_Type,
    2: kPasta_Type,
  },
  ctor: StrictPizzaOrPasta._ctor,
  nullable: true,
  flexible: false,
);

enum UnionTag {
  primitive, // 0x1
  stringNeedsConstructor, // 0x2
  vectorStringAlsoNeedsConstructor, // 0x3
}

const Map<int, UnionTag> _UnionTag_map = {
  1: UnionTag.primitive,
  2: UnionTag.stringNeedsConstructor,
  3: UnionTag.vectorStringAlsoNeedsConstructor,
};

class Union extends $fidl.XUnion {
  const Union.withPrimitive(int value)
      : _ordinal = 1,
        _data = value;

  const Union.withStringNeedsConstructor(String value)
      : _ordinal = 2,
        _data = value;

  const Union.withVectorStringAlsoNeedsConstructor(List<String> value)
      : _ordinal = 3,
        _data = value;

  Union._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  UnionTag get $tag => _UnionTag_map[_ordinal];

  int get primitive {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  String get stringNeedsConstructor {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  List<String> get vectorStringAlsoNeedsConstructor {
    if (_ordinal != 3) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'Union.primitive($primitive)';
      case 2:
        return 'Union.stringNeedsConstructor($stringNeedsConstructor)';
      case 3:
        return 'Union.vectorStringAlsoNeedsConstructor($vectorStringAlsoNeedsConstructor)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static Union _ctor(int ordinal, Object data) {
    return Union._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<Union> kUnion_Type = $fidl.XUnionType<Union>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
    2: $fidl.StringType(maybeElementCount: null, nullable: false),
    3: $fidl.VectorType<List<String>>(
        element: $fidl.StringType(maybeElementCount: null, nullable: false),
        maybeElementCount: null,
        nullable: false),
  },
  ctor: Union._ctor,
  nullable: false,
  flexible: false,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<Union> kUnion_OptType = $fidl.XUnionType<Union>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
    2: $fidl.StringType(maybeElementCount: null, nullable: false),
    3: $fidl.VectorType<List<String>>(
        element: $fidl.StringType(maybeElementCount: null, nullable: false),
        maybeElementCount: null,
        nullable: false),
  },
  ctor: Union._ctor,
  nullable: true,
  flexible: false,
);

enum FlexibleUnionTag {
  primitive, // 0x1
  stringNeedsConstructor, // 0x2
  vectorStringAlsoNeedsConstructor, // 0x3
}

const Map<int, FlexibleUnionTag> _FlexibleUnionTag_map = {
  1: FlexibleUnionTag.primitive,
  2: FlexibleUnionTag.stringNeedsConstructor,
  3: FlexibleUnionTag.vectorStringAlsoNeedsConstructor,
};

class FlexibleUnion extends $fidl.XUnion {
  const FlexibleUnion.withPrimitive(int value)
      : _ordinal = 1,
        _data = value;

  const FlexibleUnion.withStringNeedsConstructor(String value)
      : _ordinal = 2,
        _data = value;

  const FlexibleUnion.withVectorStringAlsoNeedsConstructor(List<String> value)
      : _ordinal = 3,
        _data = value;

  FlexibleUnion._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  FlexibleUnionTag get $tag => _FlexibleUnionTag_map[_ordinal];

  int get primitive {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  String get stringNeedsConstructor {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  List<String> get vectorStringAlsoNeedsConstructor {
    if (_ordinal != 3) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'FlexibleUnion.primitive($primitive)';
      case 2:
        return 'FlexibleUnion.stringNeedsConstructor($stringNeedsConstructor)';
      case 3:
        return 'FlexibleUnion.vectorStringAlsoNeedsConstructor($vectorStringAlsoNeedsConstructor)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static FlexibleUnion _ctor(int ordinal, Object data) {
    return FlexibleUnion._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<FlexibleUnion> kFlexibleUnion_Type =
    $fidl.XUnionType<FlexibleUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
    2: $fidl.StringType(maybeElementCount: null, nullable: false),
    3: $fidl.VectorType<List<String>>(
        element: $fidl.StringType(maybeElementCount: null, nullable: false),
        maybeElementCount: null,
        nullable: false),
  },
  ctor: FlexibleUnion._ctor,
  nullable: false,
  flexible: false,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<FlexibleUnion> kFlexibleUnion_OptType =
    $fidl.XUnionType<FlexibleUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
    2: $fidl.StringType(maybeElementCount: null, nullable: false),
    3: $fidl.VectorType<List<String>>(
        element: $fidl.StringType(maybeElementCount: null, nullable: false),
        maybeElementCount: null,
        nullable: false),
  },
  ctor: FlexibleUnion._ctor,
  nullable: true,
  flexible: false,
);

enum StrictUnionTag {
  primitive, // 0x1
  stringNeedsConstructor, // 0x2
  vectorStringAlsoNeedsConstructor, // 0x3
}

const Map<int, StrictUnionTag> _StrictUnionTag_map = {
  1: StrictUnionTag.primitive,
  2: StrictUnionTag.stringNeedsConstructor,
  3: StrictUnionTag.vectorStringAlsoNeedsConstructor,
};

class StrictUnion extends $fidl.XUnion {
  const StrictUnion.withPrimitive(int value)
      : _ordinal = 1,
        _data = value;

  const StrictUnion.withStringNeedsConstructor(String value)
      : _ordinal = 2,
        _data = value;

  const StrictUnion.withVectorStringAlsoNeedsConstructor(List<String> value)
      : _ordinal = 3,
        _data = value;

  StrictUnion._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  StrictUnionTag get $tag => _StrictUnionTag_map[_ordinal];

  int get primitive {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  String get stringNeedsConstructor {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  List<String> get vectorStringAlsoNeedsConstructor {
    if (_ordinal != 3) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'StrictUnion.primitive($primitive)';
      case 2:
        return 'StrictUnion.stringNeedsConstructor($stringNeedsConstructor)';
      case 3:
        return 'StrictUnion.vectorStringAlsoNeedsConstructor($vectorStringAlsoNeedsConstructor)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static StrictUnion _ctor(int ordinal, Object data) {
    return StrictUnion._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<StrictUnion> kStrictUnion_Type =
    $fidl.XUnionType<StrictUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
    2: $fidl.StringType(maybeElementCount: null, nullable: false),
    3: $fidl.VectorType<List<String>>(
        element: $fidl.StringType(maybeElementCount: null, nullable: false),
        maybeElementCount: null,
        nullable: false),
  },
  ctor: StrictUnion._ctor,
  nullable: false,
  flexible: false,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<StrictUnion> kStrictUnion_OptType =
    $fidl.XUnionType<StrictUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
    2: $fidl.StringType(maybeElementCount: null, nullable: false),
    3: $fidl.VectorType<List<String>>(
        element: $fidl.StringType(maybeElementCount: null, nullable: false),
        maybeElementCount: null,
        nullable: false),
  },
  ctor: StrictUnion._ctor,
  nullable: true,
  flexible: false,
);

enum FieldCollisionTag {
  fieldCollisionTag, // 0x1
}

const Map<int, FieldCollisionTag> _FieldCollisionTag_map = {
  1: FieldCollisionTag.fieldCollisionTag,
};

class FieldCollision extends $fidl.XUnion {
  const FieldCollision.withFieldCollisionTag(int value)
      : _ordinal = 1,
        _data = value;

  FieldCollision._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  FieldCollisionTag get $tag => _FieldCollisionTag_map[_ordinal];

  int get fieldCollisionTag {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'FieldCollision.fieldCollisionTag($fieldCollisionTag)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static FieldCollision _ctor(int ordinal, Object data) {
    return FieldCollision._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<FieldCollision> kFieldCollision_Type =
    $fidl.XUnionType<FieldCollision>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
  },
  ctor: FieldCollision._ctor,
  nullable: false,
  flexible: false,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<FieldCollision> kFieldCollision_OptType =
    $fidl.XUnionType<FieldCollision>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
  },
  ctor: FieldCollision._ctor,
  nullable: true,
  flexible: false,
);

enum ExplicitUnionTag {
  primitive, // 0x1
  stringNeedsConstructor, // 0x3
}

const Map<int, ExplicitUnionTag> _ExplicitUnionTag_map = {
  1: ExplicitUnionTag.primitive,
  3: ExplicitUnionTag.stringNeedsConstructor,
};

class ExplicitUnion extends $fidl.XUnion {
  const ExplicitUnion.withPrimitive(int value)
      : _ordinal = 1,
        _data = value;

  const ExplicitUnion.withStringNeedsConstructor(String value)
      : _ordinal = 3,
        _data = value;

  ExplicitUnion._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ExplicitUnionTag get $tag => _ExplicitUnionTag_map[_ordinal];

  int get primitive {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  String get stringNeedsConstructor {
    if (_ordinal != 3) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'ExplicitUnion.primitive($primitive)';
      case 3:
        return 'ExplicitUnion.stringNeedsConstructor($stringNeedsConstructor)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ExplicitUnion _ctor(int ordinal, Object data) {
    return ExplicitUnion._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<ExplicitUnion> kExplicitUnion_Type =
    $fidl.XUnionType<ExplicitUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
    3: $fidl.StringType(maybeElementCount: null, nullable: false),
  },
  ctor: ExplicitUnion._ctor,
  nullable: false,
  flexible: false,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<ExplicitUnion> kExplicitUnion_OptType =
    $fidl.XUnionType<ExplicitUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
    3: $fidl.StringType(maybeElementCount: null, nullable: false),
  },
  ctor: ExplicitUnion._ctor,
  nullable: true,
  flexible: false,
);

enum ReverseOrdinalUnionTag {
  first, // 0x1
  second, // 0x2
}

const Map<int, ReverseOrdinalUnionTag> _ReverseOrdinalUnionTag_map = {
  1: ReverseOrdinalUnionTag.first,
  2: ReverseOrdinalUnionTag.second,
};

class ReverseOrdinalUnion extends $fidl.XUnion {
  const ReverseOrdinalUnion.withFirst(int value)
      : _ordinal = 1,
        _data = value;

  const ReverseOrdinalUnion.withSecond(int value)
      : _ordinal = 2,
        _data = value;

  ReverseOrdinalUnion._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ReverseOrdinalUnionTag get $tag => _ReverseOrdinalUnionTag_map[_ordinal];

  int get first {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int get second {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'ReverseOrdinalUnion.first($first)';
      case 2:
        return 'ReverseOrdinalUnion.second($second)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ReverseOrdinalUnion _ctor(int ordinal, Object data) {
    return ReverseOrdinalUnion._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<ReverseOrdinalUnion> kReverseOrdinalUnion_Type =
    $fidl.XUnionType<ReverseOrdinalUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Uint32Type(),
    2: $fidl.Uint32Type(),
  },
  ctor: ReverseOrdinalUnion._ctor,
  nullable: false,
  flexible: false,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<ReverseOrdinalUnion> kReverseOrdinalUnion_OptType =
    $fidl.XUnionType<ReverseOrdinalUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Uint32Type(),
    2: $fidl.Uint32Type(),
  },
  ctor: ReverseOrdinalUnion._ctor,
  nullable: true,
  flexible: false,
);

class Pizza extends $fidl.Struct {
  const Pizza({
    @required this.toppings,
  });
  Pizza.clone(
    Pizza $orig, {
    List<String> toppings,
  }) : this(
          toppings: toppings ?? $orig.toppings,
        );

  Pizza._(List<Object> argv) : toppings = argv[0];
  final List<String> toppings;

  @override
  List<Object> get $fields {
    return <Object>[
      toppings,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'Pizza' r'(toppings: ' + toppings.toString() + r')';
  }

  static Pizza _ctor(List<Object> argv) => Pizza._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Pizza> kPizza_Type = $fidl.StructType<Pizza>(
  inlineSize: 16,
  members: <$fidl.MemberType>[
    $fidl.MemberType<List<String>>(
        type: $fidl.VectorType<List<String>>(
            element: $fidl.StringType(maybeElementCount: 16, nullable: false),
            maybeElementCount: null,
            nullable: false),
        offset: 0),
  ],
  ctor: Pizza._ctor,
);

class Pasta extends $fidl.Struct {
  const Pasta({
    @required this.sauce,
  });
  Pasta.clone(
    Pasta $orig, {
    String sauce,
  }) : this(
          sauce: sauce ?? $orig.sauce,
        );

  Pasta._(List<Object> argv) : sauce = argv[0];
  final String sauce;

  @override
  List<Object> get $fields {
    return <Object>[
      sauce,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'Pasta' r'(sauce: ' + sauce.toString() + r')';
  }

  static Pasta _ctor(List<Object> argv) => Pasta._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Pasta> kPasta_Type = $fidl.StructType<Pasta>(
  inlineSize: 16,
  members: <$fidl.MemberType>[
    $fidl.MemberType<String>(
        type: $fidl.StringType(maybeElementCount: 16, nullable: false),
        offset: 0),
  ],
  ctor: Pasta._ctor,
);

class NullableUnionStruct extends $fidl.Struct {
  const NullableUnionStruct({
    this.theUnion,
  });
  NullableUnionStruct.clone(
    NullableUnionStruct $orig, {
    Union theUnion,
  }) : this(
          theUnion: theUnion ?? $orig.theUnion,
        );

  NullableUnionStruct.cloneWithout(
    NullableUnionStruct $orig, {
    bool theUnion,
  }) : this(
          theUnion: theUnion ? null : $orig.theUnion,
        );

  NullableUnionStruct._(List<Object> argv) : theUnion = argv[0];
  final Union theUnion;

  @override
  List<Object> get $fields {
    return <Object>[
      theUnion,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'NullableUnionStruct' r'(theUnion: ' + theUnion.toString() + r')';
  }

  static NullableUnionStruct _ctor(List<Object> argv) =>
      NullableUnionStruct._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<NullableUnionStruct> kNullableUnionStruct_Type =
    $fidl.StructType<NullableUnionStruct>(
  inlineSize: 24,
  members: <$fidl.MemberType>[
    $fidl.MemberType<Union>(type: kUnion_OptType, offset: 0),
  ],
  ctor: NullableUnionStruct._ctor,
);

// ignore: unused_element, avoid_private_typedef_functions
typedef _VoidCallback = void Function();
