// WARNING: This file is machine generated by fidlgen.

library fidl_test_name_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zx;

// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters

class Handles extends $fidl.Struct {
  const Handles({
    @required this.plainHandle,
    @required this.btiHandle,
    @required this.channelHandle,
    @required this.debuglogHandle,
    @required this.eventHandle,
    @required this.eventpairHandle,
    @required this.exceptionHandle,
    @required this.fifoHandle,
    @required this.guestHandle,
    @required this.interruptHandle,
    @required this.iommuHandle,
    @required this.jobHandle,
    @required this.pagerHandle,
    @required this.pcideviceHandle,
    @required this.pmtHandle,
    @required this.portHandle,
    @required this.processHandle,
    @required this.profileHandle,
    @required this.resourceHandle,
    @required this.socketHandle,
    @required this.suspendtokenHandle,
    @required this.threadHandle,
    @required this.timerHandle,
    @required this.vcpuHandle,
    @required this.vmarHandle,
    @required this.vmoHandle,
    @required this.someProtocol,
    @required this.requestSomeProtocol,
  });
  Handles.clone(
    Handles $orig, {
    $zx.Handle plainHandle,
    $zx.Handle btiHandle,
    $zx.Channel channelHandle,
    $zx.Handle debuglogHandle,
    $zx.Handle eventHandle,
    $zx.EventPair eventpairHandle,
    $zx.Handle exceptionHandle,
    $zx.Handle fifoHandle,
    $zx.Handle guestHandle,
    $zx.Handle interruptHandle,
    $zx.Handle iommuHandle,
    $zx.Handle jobHandle,
    $zx.Handle pagerHandle,
    $zx.Handle pcideviceHandle,
    $zx.Handle pmtHandle,
    $zx.Handle portHandle,
    $zx.Handle processHandle,
    $zx.Handle profileHandle,
    $zx.Handle resourceHandle,
    $zx.Socket socketHandle,
    $zx.Handle suspendtokenHandle,
    $zx.Handle threadHandle,
    $zx.Handle timerHandle,
    $zx.Handle vcpuHandle,
    $zx.Handle vmarHandle,
    $zx.Vmo vmoHandle,
    $fidl.InterfaceHandle<SomeProtocol> someProtocol,
    $fidl.InterfaceRequest<SomeProtocol> requestSomeProtocol,
  }) : this(
          plainHandle: plainHandle ?? $orig.plainHandle,
          btiHandle: btiHandle ?? $orig.btiHandle,
          channelHandle: channelHandle ?? $orig.channelHandle,
          debuglogHandle: debuglogHandle ?? $orig.debuglogHandle,
          eventHandle: eventHandle ?? $orig.eventHandle,
          eventpairHandle: eventpairHandle ?? $orig.eventpairHandle,
          exceptionHandle: exceptionHandle ?? $orig.exceptionHandle,
          fifoHandle: fifoHandle ?? $orig.fifoHandle,
          guestHandle: guestHandle ?? $orig.guestHandle,
          interruptHandle: interruptHandle ?? $orig.interruptHandle,
          iommuHandle: iommuHandle ?? $orig.iommuHandle,
          jobHandle: jobHandle ?? $orig.jobHandle,
          pagerHandle: pagerHandle ?? $orig.pagerHandle,
          pcideviceHandle: pcideviceHandle ?? $orig.pcideviceHandle,
          pmtHandle: pmtHandle ?? $orig.pmtHandle,
          portHandle: portHandle ?? $orig.portHandle,
          processHandle: processHandle ?? $orig.processHandle,
          profileHandle: profileHandle ?? $orig.profileHandle,
          resourceHandle: resourceHandle ?? $orig.resourceHandle,
          socketHandle: socketHandle ?? $orig.socketHandle,
          suspendtokenHandle: suspendtokenHandle ?? $orig.suspendtokenHandle,
          threadHandle: threadHandle ?? $orig.threadHandle,
          timerHandle: timerHandle ?? $orig.timerHandle,
          vcpuHandle: vcpuHandle ?? $orig.vcpuHandle,
          vmarHandle: vmarHandle ?? $orig.vmarHandle,
          vmoHandle: vmoHandle ?? $orig.vmoHandle,
          someProtocol: someProtocol ?? $orig.someProtocol,
          requestSomeProtocol: requestSomeProtocol ?? $orig.requestSomeProtocol,
        );

  Handles._(List<Object> argv)
      : plainHandle = argv[0],
        btiHandle = argv[1],
        channelHandle = argv[2],
        debuglogHandle = argv[3],
        eventHandle = argv[4],
        eventpairHandle = argv[5],
        exceptionHandle = argv[6],
        fifoHandle = argv[7],
        guestHandle = argv[8],
        interruptHandle = argv[9],
        iommuHandle = argv[10],
        jobHandle = argv[11],
        pagerHandle = argv[12],
        pcideviceHandle = argv[13],
        pmtHandle = argv[14],
        portHandle = argv[15],
        processHandle = argv[16],
        profileHandle = argv[17],
        resourceHandle = argv[18],
        socketHandle = argv[19],
        suspendtokenHandle = argv[20],
        threadHandle = argv[21],
        timerHandle = argv[22],
        vcpuHandle = argv[23],
        vmarHandle = argv[24],
        vmoHandle = argv[25],
        someProtocol = argv[26],
        requestSomeProtocol = argv[27];
  final $zx.Handle plainHandle;
  final $zx.Handle btiHandle;
  final $zx.Channel channelHandle;
  final $zx.Handle debuglogHandle;
  final $zx.Handle eventHandle;
  final $zx.EventPair eventpairHandle;
  final $zx.Handle exceptionHandle;
  final $zx.Handle fifoHandle;
  final $zx.Handle guestHandle;
  final $zx.Handle interruptHandle;
  final $zx.Handle iommuHandle;
  final $zx.Handle jobHandle;
  final $zx.Handle pagerHandle;
  final $zx.Handle pcideviceHandle;
  final $zx.Handle pmtHandle;
  final $zx.Handle portHandle;
  final $zx.Handle processHandle;
  final $zx.Handle profileHandle;
  final $zx.Handle resourceHandle;
  final $zx.Socket socketHandle;
  final $zx.Handle suspendtokenHandle;
  final $zx.Handle threadHandle;
  final $zx.Handle timerHandle;
  final $zx.Handle vcpuHandle;
  final $zx.Handle vmarHandle;
  final $zx.Vmo vmoHandle;
  final $fidl.InterfaceHandle<SomeProtocol> someProtocol;
  final $fidl.InterfaceRequest<SomeProtocol> requestSomeProtocol;

  @override
  List<Object> get $fields {
    return <Object>[
      plainHandle,
      btiHandle,
      channelHandle,
      debuglogHandle,
      eventHandle,
      eventpairHandle,
      exceptionHandle,
      fifoHandle,
      guestHandle,
      interruptHandle,
      iommuHandle,
      jobHandle,
      pagerHandle,
      pcideviceHandle,
      pmtHandle,
      portHandle,
      processHandle,
      profileHandle,
      resourceHandle,
      socketHandle,
      suspendtokenHandle,
      threadHandle,
      timerHandle,
      vcpuHandle,
      vmarHandle,
      vmoHandle,
      someProtocol,
      requestSomeProtocol,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'Handles' r'(plainHandle: ' +
        plainHandle.toString() +
        r', btiHandle: ' +
        btiHandle.toString() +
        r', channelHandle: ' +
        channelHandle.toString() +
        r', debuglogHandle: ' +
        debuglogHandle.toString() +
        r', eventHandle: ' +
        eventHandle.toString() +
        r', eventpairHandle: ' +
        eventpairHandle.toString() +
        r', exceptionHandle: ' +
        exceptionHandle.toString() +
        r', fifoHandle: ' +
        fifoHandle.toString() +
        r', guestHandle: ' +
        guestHandle.toString() +
        r', interruptHandle: ' +
        interruptHandle.toString() +
        r', iommuHandle: ' +
        iommuHandle.toString() +
        r', jobHandle: ' +
        jobHandle.toString() +
        r', pagerHandle: ' +
        pagerHandle.toString() +
        r', pcideviceHandle: ' +
        pcideviceHandle.toString() +
        r', pmtHandle: ' +
        pmtHandle.toString() +
        r', portHandle: ' +
        portHandle.toString() +
        r', processHandle: ' +
        processHandle.toString() +
        r', profileHandle: ' +
        profileHandle.toString() +
        r', resourceHandle: ' +
        resourceHandle.toString() +
        r', socketHandle: ' +
        socketHandle.toString() +
        r', suspendtokenHandle: ' +
        suspendtokenHandle.toString() +
        r', threadHandle: ' +
        threadHandle.toString() +
        r', timerHandle: ' +
        timerHandle.toString() +
        r', vcpuHandle: ' +
        vcpuHandle.toString() +
        r', vmarHandle: ' +
        vmarHandle.toString() +
        r', vmoHandle: ' +
        vmoHandle.toString() +
        r', someProtocol: ' +
        someProtocol.toString() +
        r', requestSomeProtocol: ' +
        requestSomeProtocol.toString() +
        r')';
  }

  static Handles _ctor(List<Object> argv) => Handles._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<Handles> kHandles_Type = $fidl.StructType<Handles>(
  inlineSize: 112,
  members: <$fidl.MemberType>[
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 0),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 4),
    $fidl.MemberType<$zx.Channel>(
        type: $fidl.ChannelType(nullable: false), offset: 8),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 12),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 16),
    $fidl.MemberType<$zx.EventPair>(
        type: $fidl.EventPairType(nullable: false), offset: 20),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 24),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 28),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 32),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 36),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 40),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 44),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 48),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 52),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 56),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 60),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 64),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 68),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 72),
    $fidl.MemberType<$zx.Socket>(
        type: $fidl.SocketType(nullable: false), offset: 76),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 80),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 84),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 88),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 92),
    $fidl.MemberType<$zx.Handle>(
        type: $fidl.HandleType(nullable: false), offset: 96),
    $fidl.MemberType<$zx.Vmo>(
        type: $fidl.VmoType(nullable: false), offset: 100),
    $fidl.MemberType<$fidl.InterfaceHandle<SomeProtocol>>(
        type: $fidl.InterfaceHandleType<SomeProtocol>(nullable: false),
        offset: 104),
    $fidl.MemberType<$fidl.InterfaceRequest<SomeProtocol>>(
        type: $fidl.InterfaceRequestType<SomeProtocol>(nullable: false),
        offset: 108),
  ],
  ctor: Handles._ctor,
);

// ignore: unused_element, avoid_private_typedef_functions
typedef _VoidCallback = void Function();

// someMethod: ()
const int _kSomeProtocol_SomeMethod_Ordinal = 0x1a5a7f0e00000000;
const int _kSomeProtocol_SomeMethod_GenOrdinal = 0x770a27eb8815af1e;
const $fidl.MethodType _kSomeProtocol_SomeMethod_Type = $fidl.MethodType(
  request: null,
  response: null,
  name: r"SomeProtocol.SomeMethod",
  requestInlineSize: 0,
  responseInlineSize: 0,
);

abstract class SomeProtocol extends $fidl.Service {
  static const String $serviceName = null;
  @override
  $fidl.ServiceData get $serviceData => SomeProtocolData();
  $async.Future<void> someMethod();
}

class SomeProtocolData implements $fidl.ServiceData<SomeProtocol> {
  const SomeProtocolData();

  @override
  String getName() {
    return SomeProtocol.$serviceName;
  }

  @override
  $fidl.AsyncBinding getBinding() {
    return SomeProtocolBinding();
  }
}

class SomeProtocolProxy extends $fidl.AsyncProxy<SomeProtocol>
    implements SomeProtocol {
  SomeProtocolProxy()
      : super($fidl.AsyncProxyController<SomeProtocol>(
            $serviceName: null, $interfaceName: r'SomeProtocol')) {
    ctrl.onResponse = _handleResponse;
  }

  @override
  $fidl.ServiceData get $serviceData => SomeProtocolData();

  void _handleEvent($fidl.Message $message) {
    final $fidl.Decoder $decoder = $fidl.Decoder($message)
      ..claimMemory($fidl.kMessageHeaderSize);
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        ctrl.close();
        break;
    }
  }

  void _handleResponse($fidl.Message $message) {
    final int $txid = $message.txid;
    if ($txid == 0) {
      _handleEvent($message);
      return;
    }
    final $async.Completer $completer = ctrl.getCompleter($txid);
    if ($completer == null) {
      $message.closeHandles();
      return;
    }
    final $fidl.Decoder $decoder = $fidl.Decoder($message)
      ..claimMemory($fidl.kMessageHeaderSize);
    switch ($message.ordinal) {
      default:
        ctrl.proxyError(
            $fidl.FidlError('Unexpected message ordinal: ${$message.ordinal}'));
        ctrl.close();
        break;
    }
  }

  @override
  $async.Future<void> someMethod() async {
    if (!ctrl.isBound) {
      return $async.Future.error(
          $fidl.FidlStateException('Proxy<${ctrl.$interfaceName}> is closed.'),
          StackTrace.current);
    }

    final $fidl.Encoder $encoder = $fidl.Encoder();
    $encoder.encodeMessageHeader(_kSomeProtocol_SomeMethod_GenOrdinal, 0);
    return $async.Future.sync(() {
      ctrl.sendMessage($encoder.message);
    });
  }
}

class SomeProtocolBinding extends $fidl.AsyncBinding<SomeProtocol> {
  SomeProtocolBinding() : super(r"SomeProtocol");

  @override
  void handleMessage($fidl.Message $message, $fidl.MessageSink $respond) {
    final $fidl.Decoder $decoder = $fidl.Decoder($message)
      ..claimMemory($fidl.kMessageHeaderSize);
    switch ($message.ordinal) {
      case _kSomeProtocol_SomeMethod_Ordinal:
      case _kSomeProtocol_SomeMethod_GenOrdinal:
        final String _name = _kSomeProtocol_SomeMethod_Type.name;
        try {
          Timeline.startSync(_name);
          final List<$fidl.MemberType> $types =
              _kSomeProtocol_SomeMethod_Type.request;
          $decoder.claimMemory(
              _kSomeProtocol_SomeMethod_Type.decodeRequestInlineSize($decoder));
          final $async.Future<void> $future = impl.someMethod();
          // ignore: avoid_catches_without_on_clauses
        } catch (_e) {
          close();
          print('Exception handling method call $_name: $_e');
          rethrow;
        } finally {
          Timeline.finishSync();
        }
        break;
      default:
        throw $fidl.FidlError(
            r'Unexpected message name for SomeProtocolBinding');
    }
  }
}
