// WARNING: This file is machine generated by fidlgen.

library fidl_test_name_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zx;

// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters

enum UnionTag {
  primitive,
  stringNeedsConstructor,
  vectorStringAlsoNeedsConstructor,
}

class Union extends $fidl.Union {
  const Union.withPrimitive(int value)
      : _data = value,
        _tag = UnionTag.primitive;

  const Union.withStringNeedsConstructor(String value)
      : _data = value,
        _tag = UnionTag.stringNeedsConstructor;

  const Union.withVectorStringAlsoNeedsConstructor(List<String> value)
      : _data = value,
        _tag = UnionTag.vectorStringAlsoNeedsConstructor;

  Union._(UnionTag tag, Object data)
      : _tag = tag,
        _data = data;

  final UnionTag _tag;
  final _data;
  int get primitive {
    if (_tag != UnionTag.primitive) {
      return null;
    }
    return _data;
  }

  String get stringNeedsConstructor {
    if (_tag != UnionTag.stringNeedsConstructor) {
      return null;
    }
    return _data;
  }

  List<String> get vectorStringAlsoNeedsConstructor {
    if (_tag != UnionTag.vectorStringAlsoNeedsConstructor) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_tag) {
      case UnionTag.primitive:
        return r'Union.primitive($primitive)';
      case UnionTag.stringNeedsConstructor:
        return r'Union.stringNeedsConstructor($stringNeedsConstructor)';
      case UnionTag.vectorStringAlsoNeedsConstructor:
        return r'Union.vectorStringAlsoNeedsConstructor($vectorStringAlsoNeedsConstructor)';
      default:
        return null;
    }
  }

  UnionTag get $tag => _tag;
  // TODO: remove, see: FIDL-587
  UnionTag get tag => _tag;

  @override
  int get $index => _tag.index;

  @override
  Object get $data => _data;

  static Union _ctor(int index, Object data) {
    return Union._(UnionTag.values[index], data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<Union> kUnion_Type = $fidl.UnionType<Union>(
  inlineSizeOld: 24,
  inlineSizeV1: 24,
  members: <$fidl.MemberType>[
    $fidl.MemberType<int>(
        type: $fidl.Int32Type(), offsetOld: 8, offsetV1: -1 /* unused */),
    $fidl.MemberType<String>(
        type: $fidl.StringType(maybeElementCount: null, nullable: false),
        offsetOld: 8,
        offsetV1: -1 /* unused */),
    $fidl.MemberType<List<String>>(
        type: $fidl.VectorType<List<String>>(
            element: $fidl.StringType(maybeElementCount: null, nullable: false),
            maybeElementCount: null,
            nullable: false),
        offsetOld: 8,
        offsetV1: -1 /* unused */),
  ],
  ctor: Union._ctor,
  ordinalToIndex: <int, int>{
    1: 0,
    2: 1,
    3: 2,
  },
);

enum FieldCollisionTag {
  fieldCollisionTag,
}

class FieldCollision extends $fidl.Union {
  const FieldCollision.withFieldCollisionTag(int value)
      : _data = value,
        _tag = FieldCollisionTag.fieldCollisionTag;

  FieldCollision._(FieldCollisionTag tag, Object data)
      : _tag = tag,
        _data = data;

  final FieldCollisionTag _tag;
  final _data;
  int get fieldCollisionTag {
    if (_tag != FieldCollisionTag.fieldCollisionTag) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_tag) {
      case FieldCollisionTag.fieldCollisionTag:
        return r'FieldCollision.fieldCollisionTag($fieldCollisionTag)';
      default:
        return null;
    }
  }

  FieldCollisionTag get $tag => _tag;
  // TODO: remove, see: FIDL-587
  FieldCollisionTag get tag => _tag;

  @override
  int get $index => _tag.index;

  @override
  Object get $data => _data;

  static FieldCollision _ctor(int index, Object data) {
    return FieldCollision._(FieldCollisionTag.values[index], data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<FieldCollision> kFieldCollision_Type =
    $fidl.UnionType<FieldCollision>(
  inlineSizeOld: 8,
  inlineSizeV1: 24,
  members: <$fidl.MemberType>[
    $fidl.MemberType<int>(
        type: $fidl.Int32Type(), offsetOld: 4, offsetV1: -1 /* unused */),
  ],
  ctor: FieldCollision._ctor,
  ordinalToIndex: <int, int>{
    1: 0,
  },
);

enum ExplicitUnionTag {
  primitive,
  stringNeedsConstructor,
}

class ExplicitUnion extends $fidl.Union {
  const ExplicitUnion.withPrimitive(int value)
      : _data = value,
        _tag = ExplicitUnionTag.primitive;

  const ExplicitUnion.withStringNeedsConstructor(String value)
      : _data = value,
        _tag = ExplicitUnionTag.stringNeedsConstructor;

  ExplicitUnion._(ExplicitUnionTag tag, Object data)
      : _tag = tag,
        _data = data;

  final ExplicitUnionTag _tag;
  final _data;
  int get primitive {
    if (_tag != ExplicitUnionTag.primitive) {
      return null;
    }
    return _data;
  }

  String get stringNeedsConstructor {
    if (_tag != ExplicitUnionTag.stringNeedsConstructor) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_tag) {
      case ExplicitUnionTag.primitive:
        return r'ExplicitUnion.primitive($primitive)';
      case ExplicitUnionTag.stringNeedsConstructor:
        return r'ExplicitUnion.stringNeedsConstructor($stringNeedsConstructor)';
      default:
        return null;
    }
  }

  ExplicitUnionTag get $tag => _tag;
  // TODO: remove, see: FIDL-587
  ExplicitUnionTag get tag => _tag;

  @override
  int get $index => _tag.index;

  @override
  Object get $data => _data;

  static ExplicitUnion _ctor(int index, Object data) {
    return ExplicitUnion._(ExplicitUnionTag.values[index], data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.UnionType<ExplicitUnion> kExplicitUnion_Type =
    $fidl.UnionType<ExplicitUnion>(
  inlineSizeOld: 24,
  inlineSizeV1: 24,
  members: <$fidl.MemberType>[
    $fidl.MemberType<int>(
        type: $fidl.Int32Type(), offsetOld: 8, offsetV1: -1 /* unused */),
    $fidl.MemberType<String>(
        type: $fidl.StringType(maybeElementCount: null, nullable: false),
        offsetOld: 8,
        offsetV1: -1 /* unused */),
  ],
  ctor: ExplicitUnion._ctor,
  ordinalToIndex: <int, int>{
    1: 0,
    3: 1,
  },
);

class NullableUnionStruct extends $fidl.Struct {
  const NullableUnionStruct({
    this.theUnion,
  });
  NullableUnionStruct.clone(
    NullableUnionStruct $orig, {
    Union theUnion,
  }) : this(
          theUnion: theUnion ?? $orig.theUnion,
        );

  NullableUnionStruct.cloneWithout(
    NullableUnionStruct $orig, {
    bool theUnion,
  }) : this(
          theUnion: theUnion ? null : $orig.theUnion,
        );

  NullableUnionStruct._(List<Object> argv) : theUnion = argv[0];
  final Union theUnion;

  @override
  List<Object> get $fields {
    return <Object>[
      theUnion,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'NullableUnionStruct' r'(theUnion: ' + theUnion.toString() + r')';
  }

  static NullableUnionStruct _ctor(List<Object> argv) =>
      NullableUnionStruct._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<NullableUnionStruct> kNullableUnionStruct_Type =
    $fidl.StructType<NullableUnionStruct>(
  inlineSizeOld: 8,
  inlineSizeV1: 24,
  members: <$fidl.MemberType>[
    $fidl.MemberType<Union>(
        type: $fidl.OptUnionType<Union>(element: kUnion_Type),
        offsetOld: 0,
        offsetV1: 0),
  ],
  ctor: NullableUnionStruct._ctor,
);

// ignore: unused_element, avoid_private_typedef_functions
typedef _VoidCallback = void Function();
