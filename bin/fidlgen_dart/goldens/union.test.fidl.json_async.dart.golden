// WARNING: This file is machine generated by fidlgen.

library fidl_test_name_async;

import 'dart:async' as $async;
import 'dart:core' hide Set;
import 'dart:developer';
import 'dart:typed_data';

import 'package:fidl/fidl.dart' as $fidl;
import 'package:meta/meta.dart';
import 'package:zircon/zircon.dart' as $zx;

// ignore_for_file: always_specify_types
// ignore_for_file: avoid_positional_boolean_parameters
// ignore_for_file: avoid_returning_null
// ignore_for_file: cascade_invocations
// ignore_for_file: constant_identifier_names
// ignore_for_file: one_member_abstracts
// ignore_for_file: prefer_constructors_over_static_methods
// ignore_for_file: prefer_single_quotes
// ignore_for_file: public_member_api_docs
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: library_prefixes
// ignore_for_file: prefer_typing_uninitialized_variables
// ignore_for_file: avoid_js_rounded_ints
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: prefer_generic_function_type_aliases
// ignore_for_file: prefer_equal_for_default_values
// ignore_for_file: avoid_catches_without_on_clauses
// ignore_for_file: unused_shown_name
// ignore_for_file: unnecessary_lambdas
// ignore_for_file: comment_references
// ignore_for_file: avoid_unused_constructor_parameters

enum UnionTag {
  primitive, // 0x1
  stringNeedsConstructor, // 0x2
  vectorStringAlsoNeedsConstructor, // 0x3
}

const Map<int, UnionTag> _UnionTag_map = {
  1: UnionTag.primitive,
  2: UnionTag.stringNeedsConstructor,
  3: UnionTag.vectorStringAlsoNeedsConstructor,
};

class Union extends $fidl.XUnion {
  const Union.withPrimitive(int value)
      : _ordinal = 1,
        _data = value;

  const Union.withStringNeedsConstructor(String value)
      : _ordinal = 2,
        _data = value;

  const Union.withVectorStringAlsoNeedsConstructor(List<String> value)
      : _ordinal = 3,
        _data = value;

  Union._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  UnionTag get $tag => _UnionTag_map[_ordinal];

  int get primitive {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  String get stringNeedsConstructor {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  List<String> get vectorStringAlsoNeedsConstructor {
    if (_ordinal != 3) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'Union.primitive($primitive)';
      case 2:
        return 'Union.stringNeedsConstructor($stringNeedsConstructor)';
      case 3:
        return 'Union.vectorStringAlsoNeedsConstructor($vectorStringAlsoNeedsConstructor)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static Union _ctor(int ordinal, Object data) {
    return Union._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<Union> kUnion_Type = $fidl.XUnionType<Union>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
    2: $fidl.StringType(maybeElementCount: null, nullable: false),
    3: $fidl.VectorType<List<String>>(
        element: $fidl.StringType(maybeElementCount: null, nullable: false),
        maybeElementCount: null,
        nullable: false),
  },
  readToWriteOrdinals: <int, int>{
    1: 1,
    2: 2,
    3: 3,
  },
  ctor: Union._ctor,
  nullable: false,
  flexible: false,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<Union> kUnion_OptType = $fidl.XUnionType<Union>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
    2: $fidl.StringType(maybeElementCount: null, nullable: false),
    3: $fidl.VectorType<List<String>>(
        element: $fidl.StringType(maybeElementCount: null, nullable: false),
        maybeElementCount: null,
        nullable: false),
  },
  readToWriteOrdinals: <int, int>{
    1: 1,
    2: 2,
    3: 3,
  },
  ctor: Union._ctor,
  nullable: true,
  flexible: false,
);

enum FieldCollisionTag {
  fieldCollisionTag, // 0x1
}

const Map<int, FieldCollisionTag> _FieldCollisionTag_map = {
  1: FieldCollisionTag.fieldCollisionTag,
};

class FieldCollision extends $fidl.XUnion {
  const FieldCollision.withFieldCollisionTag(int value)
      : _ordinal = 1,
        _data = value;

  FieldCollision._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  FieldCollisionTag get $tag => _FieldCollisionTag_map[_ordinal];

  int get fieldCollisionTag {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'FieldCollision.fieldCollisionTag($fieldCollisionTag)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static FieldCollision _ctor(int ordinal, Object data) {
    return FieldCollision._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<FieldCollision> kFieldCollision_Type =
    $fidl.XUnionType<FieldCollision>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
  },
  readToWriteOrdinals: <int, int>{
    1: 1,
  },
  ctor: FieldCollision._ctor,
  nullable: false,
  flexible: false,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<FieldCollision> kFieldCollision_OptType =
    $fidl.XUnionType<FieldCollision>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
  },
  readToWriteOrdinals: <int, int>{
    1: 1,
  },
  ctor: FieldCollision._ctor,
  nullable: true,
  flexible: false,
);

enum ExplicitUnionTag {
  primitive, // 0x1
  stringNeedsConstructor, // 0x3
}

const Map<int, ExplicitUnionTag> _ExplicitUnionTag_map = {
  1: ExplicitUnionTag.primitive,
  3: ExplicitUnionTag.stringNeedsConstructor,
};

class ExplicitUnion extends $fidl.XUnion {
  const ExplicitUnion.withPrimitive(int value)
      : _ordinal = 1,
        _data = value;

  const ExplicitUnion.withStringNeedsConstructor(String value)
      : _ordinal = 3,
        _data = value;

  ExplicitUnion._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ExplicitUnionTag get $tag => _ExplicitUnionTag_map[_ordinal];

  int get primitive {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  String get stringNeedsConstructor {
    if (_ordinal != 3) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'ExplicitUnion.primitive($primitive)';
      case 3:
        return 'ExplicitUnion.stringNeedsConstructor($stringNeedsConstructor)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ExplicitUnion _ctor(int ordinal, Object data) {
    return ExplicitUnion._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<ExplicitUnion> kExplicitUnion_Type =
    $fidl.XUnionType<ExplicitUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
    3: $fidl.StringType(maybeElementCount: null, nullable: false),
  },
  readToWriteOrdinals: <int, int>{
    1: 1,
    3: 3,
  },
  ctor: ExplicitUnion._ctor,
  nullable: false,
  flexible: false,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<ExplicitUnion> kExplicitUnion_OptType =
    $fidl.XUnionType<ExplicitUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Int32Type(),
    3: $fidl.StringType(maybeElementCount: null, nullable: false),
  },
  readToWriteOrdinals: <int, int>{
    1: 1,
    3: 3,
  },
  ctor: ExplicitUnion._ctor,
  nullable: true,
  flexible: false,
);

enum ReverseOrdinalUnionTag {
  first, // 0x1
  second, // 0x2
}

const Map<int, ReverseOrdinalUnionTag> _ReverseOrdinalUnionTag_map = {
  1: ReverseOrdinalUnionTag.first,
  2: ReverseOrdinalUnionTag.second,
};

class ReverseOrdinalUnion extends $fidl.XUnion {
  const ReverseOrdinalUnion.withFirst(int value)
      : _ordinal = 1,
        _data = value;

  const ReverseOrdinalUnion.withSecond(int value)
      : _ordinal = 2,
        _data = value;

  ReverseOrdinalUnion._(int ordinal, Object data)
      : _ordinal = ordinal,
        _data = data;

  final int _ordinal;
  final _data;

  ReverseOrdinalUnionTag get $tag => _ReverseOrdinalUnionTag_map[_ordinal];

  int get first {
    if (_ordinal != 1) {
      return null;
    }
    return _data;
  }

  int get second {
    if (_ordinal != 2) {
      return null;
    }
    return _data;
  }

  @override
  String toString() {
    switch (_ordinal) {
      case 1:
        return 'ReverseOrdinalUnion.first($first)';
      case 2:
        return 'ReverseOrdinalUnion.second($second)';
      default:
        return null;
    }
  }

  @override
  int get $ordinal => _ordinal;

  @override
  Object get $data => _data;

  static ReverseOrdinalUnion _ctor(int ordinal, Object data) {
    return ReverseOrdinalUnion._(ordinal, data);
  }
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<ReverseOrdinalUnion> kReverseOrdinalUnion_Type =
    $fidl.XUnionType<ReverseOrdinalUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Uint32Type(),
    2: $fidl.Uint32Type(),
  },
  readToWriteOrdinals: <int, int>{
    1: 1,
    2: 2,
  },
  ctor: ReverseOrdinalUnion._ctor,
  nullable: false,
  flexible: false,
);
// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.XUnionType<ReverseOrdinalUnion> kReverseOrdinalUnion_OptType =
    $fidl.XUnionType<ReverseOrdinalUnion>(
  members: <int, $fidl.FidlType>{
    1: $fidl.Uint32Type(),
    2: $fidl.Uint32Type(),
  },
  readToWriteOrdinals: <int, int>{
    1: 1,
    2: 2,
  },
  ctor: ReverseOrdinalUnion._ctor,
  nullable: true,
  flexible: false,
);

class NullableUnionStruct extends $fidl.Struct {
  const NullableUnionStruct({
    this.theUnion,
  });
  NullableUnionStruct.clone(
    NullableUnionStruct $orig, {
    Union theUnion,
  }) : this(
          theUnion: theUnion ?? $orig.theUnion,
        );

  NullableUnionStruct.cloneWithout(
    NullableUnionStruct $orig, {
    bool theUnion,
  }) : this(
          theUnion: theUnion ? null : $orig.theUnion,
        );

  NullableUnionStruct._(List<Object> argv) : theUnion = argv[0];
  final Union theUnion;

  @override
  List<Object> get $fields {
    return <Object>[
      theUnion,
    ];
  }

  @override
  String toString() {
    // ignore: prefer_interpolation_to_compose_strings
    return r'NullableUnionStruct' r'(theUnion: ' + theUnion.toString() + r')';
  }

  static NullableUnionStruct _ctor(List<Object> argv) =>
      NullableUnionStruct._(argv);
}

// See FIDL-308:
// ignore: recursive_compile_time_constant
const $fidl.StructType<NullableUnionStruct> kNullableUnionStruct_Type =
    $fidl.StructType<NullableUnionStruct>(
  inlineSize: 24,
  members: <$fidl.MemberType>[
    $fidl.MemberType<Union>(type: kUnion_OptType, offset: 0),
  ],
  ctor: NullableUnionStruct._ctor,
);

// ignore: unused_element, avoid_private_typedef_functions
typedef _VoidCallback = void Function();
